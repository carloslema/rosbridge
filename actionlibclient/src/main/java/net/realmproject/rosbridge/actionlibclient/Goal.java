package net.realmproject.rosbridge.actionlibclient;


import java.io.Closeable;
import java.io.IOException;
import java.util.Optional;
import java.util.concurrent.Future;
import java.util.function.Consumer;

import net.realmproject.rosbridge.actionlibclient.datatypes.Feedback;
import net.realmproject.rosbridge.actionlibclient.datatypes.GoalStatus;
import net.realmproject.rosbridge.actionlibclient.datatypes.Result;
import net.realmproject.rosbridge.actionlibclient.datatypes.GoalStatus.GoalState;


public interface Goal<T> extends Closeable {

    /**
     * Starts this goal, passing the submitted data
     * 
     * @throws InterruptedException
     * @throws IOException
     */
    void submit(T goalData) throws InterruptedException, IOException;

    /**
     * Starts this goal, wrapping the input in a "field": "value". When the goal
     * message is defined from a single data structure, Actionlib will still
     * wrap it in a new message. This is a convenience method intended to remove
     * the requirement of defining such a data structure, or create a Map
     * explicitly.
     * 
     * @throws InterruptedException
     * @throws IOException
     */
    void submit(String field, T goalData) throws InterruptedException, IOException;

    /**
     * Set a custom handler for status messages. These normally don't need to be
     * tracked manually, as the current state is available by calling
     * {@link Goal#getState()}
     */
    void setStatusHandler(Consumer<GoalStatus> statusHandler);

    /**
     * Sets a custom handler for result messages. These normally don't need to
     * be tracked manually, as a {@link Future} for the result can be retreived
     * by calling {@link Goal#getResult()}
     */
    void setResultHandler(Consumer<Result<T>> resultHandler);

    /**
     * Sets a custom handler for feedback messages.
     * 
     * @param feedbackHandler
     */
    void setFeedbackHandler(Consumer<Feedback<T>> feedbackHandler);

    /**
     * Sets a custom handler for goal completion.
     * 
     * @param completionHandler
     */
    void setCompletionHandler(Runnable completionHandler);

    /**
     * Get the current state of the Goal, as represented by a {@link GoalState}.
     * 
     * @return
     */
    GoalState getState();

    /**
     * Get a {@link Future} representing the result of this Goal.
     */
    Future<Optional<Result<T>>> getResult();

    /**
     * Attempt to cancel this goal
     * 
     * @throws InterruptedException
     * @throws IOException
     */
    void cancel() throws InterruptedException, IOException;


    /**
     * Returns true if the goal has succeeded <b>and</b> we have a result, or if
     * the goal has failed, or if it is closed.
     */
    boolean isComplete();

    /**
     * Returns true iff the goal has completed
     */
    default boolean isGoalStateCompleted() {
        return (isGoalStateFailed() || isGoalStateSucceeded());
    }

    /**
     * Returns true iff the goal has completed UNsuccessfully
     */
    boolean isGoalStateFailed();

    /**
     * Returns true iff the goal has completed successfully
     */
    boolean isGoalStateSucceeded();

    /**
     * Returns true if the goal has been closed
     */
    boolean isClosed();

    /**
     * Returns the autogenerated goal id
     **/
    String getId();


}
